# Compression/Crypto Indicators

ZSTD/libarchive traces are present in native artifacts. `zstd_strings_libjnimultiengine.txt` and `libjnimulti_crypto_scan.txt` list ZSTD symbols such as `ZSTD_createDStream`, `ZSTD_decompressStream`, and `ZSTD_versionNumber`, alongside libarchive entry points like `archive_read_support_filter_zstd`, `archive_read_support_format_zip/tar`, and multiple `archive_entry_*` helpers. The analysis scripts also encode compression signatures (ZSTD magic `28 b5 2f fd`, GZIP `1f 8b 08`, ZLIB `78 9c/01/da`) and the decompiled APKs include Okio `GzipSource`/`DeflaterSink`, indicating standard gzip/zlib plumbing in app-level code.

Triangulation in `libjnimultiengine.so` string tables (SmartEngines_apktool copy) shows concrete offsets for container-related symbols: `archive_read_support_format_tar` `0x000900fc`, `archive_read_support_filter_zstd` `0x0009011c`, `archive_read_support_format_zip` `0x0009013d`, `archive_read_open_memory`/`archive_read_open_memory2` `0x00090178`/`0x00091ecd`, `archive_read_next_header` `0x000901a3`/`0x00092254`, `archive_read_data` `0x000901bc`/`0x00091e0b`, `archive_entry_pathname` `0x000901f8`/`0x00090fd5`, and `archive_entry_size` `0x0009020f`/`0x00091094`. ZSTD strings land nearby: `ZSTD_createDStream` `0x00091efb`/`0x0009264e`, `ZSTD_decompressStream` `0x00091f4f`/`0x00092859`, `ZSTD_createDCtx_advanced` `0x000923a3`, `ZSTD_decompressDCtx` `0x0009252b`. ZIP indicators include `zip_field_name` at `0x0028d63b` (same binary) and libzippp RTTI strings (`ZipArchive`, `ZipEntry`) at `0x00337080`/`0x00337098` in `analysis/binary_strings_hits.txt`. Callsite mapping adds code offsets for real PLT invocations; after PLT0 correction, the true `archive_read_open_memory2` callsite is `0x02557c60` (see `analysis/open_memory2_callsite_02557c60_summary.md`).
BL scans of the archive cluster show `archive_read_support_filter_zstd` calls from `0x0255a61c` and `0x0255ae88` (PLT-resolved), and `TextEngineImpl::InitFromOwnedZipBuffer` reaches this cluster via a BL target at `0x02558a08` (see `analysis/function_bl_scan_archive_cluster.md`).
`archive_open_FUN_026eaef0` @ `0x026eaef0` performs `archive_read_open_filenames` and file-open handling (`__open_2`), while `archive_read_open_memory2` occurs inside `FUN_02557a90` at `0x02557c60` (see `analysis/open_memory2_callsite_02557c60_summary.md`).
Heuristic backtracking from `archive_read_support_filter_zstd` callsites suggests multiple small functions around `0x025579a8`-`0x02557a14` rather than a single monolithic init function (see `analysis/callsite_function_map.md`).
PLT callsite mapping shows a likely libarchive wrapper at `0x02557a90` (calls `archive_read_open_filenames`, `archive_read_data`, `archive_entry_pathname`, and `archive_read_open_memory2` at `0x02557c60`) (see `analysis/plt_callsites_function_map.md` and `analysis/open_memory2_callsite_02557c60_summary.md`).
Direct call mapping shows `0x02558a08` -> `0x02557a14` (invokes `archive_read_support_filter_zstd`) -> `0x02557a90` (libarchive wrapper); the `__open_2` path is handled separately by `0x026eaef0` (see `analysis/function_direct_calls.md` and `analysis/function_plt_targets_resolved.md`).
Instruction context around these PLT callsites is captured in `analysis/callsite_context_archive_wrapper.md`, and a Ghidra trace checklist is in `analysis/ghidra_trace_worksheet.md`.
An ADRP/ADD scan shows X2 at `archive_read_open_filenames` callsites points to error strings rather than filenames, so argument roles should be validated in Ghidra (see `analysis/open_filenames_arg_scan.md`).

Crypto indicators show AEAD-capable providers and hash constants rather than a full block-cipher implementation dump. BouncyCastle smali includes `AEADParameters` with `GCMParameterSpec` (`BaseBlockCipher$AEADGenericBlockCipher`), while `libjnimulti_crypto_scan.txt` reports SHA-256 round constants at `SHA256_K_LE offset=0x390a80` and no AES S-box match in that scan. `bundle_crypto_constants.txt` flags IV offsets (and occasional key offsets) inside `.se` bundles, suggesting encrypted payload structure even where AES/CHACHA constant prefixes were not detected.

Post-XOR scans of `.se` payloads (header stripped, XOR key applied) did not surface ZSTD or ZIP local header signatures. High counts of ZLIB/GZIP/JSON byte patterns appear, but GZIP offsets fail to decompress and long ASCII runs are absent, implying those hits are likely false positives in high-entropy data. See `analysis/postxor_magic_scan.md`, `analysis/postxor_magic_scan_summary.md`, `analysis/postxor_ascii_runs.md`, and `analysis/postxor_gzip_probe.md`.

The captured `zstd_out_*.bin` dumps in `se_dumps/latest` appear structured rather than encrypted: low entropy (2.36-4.09), high zero-byte ratios (0.48-0.72), and many small 32-bit values, with no ASCII strings or archive magics detected. See `analysis/zstd_out_scan.md`, `analysis/zstd_out_strings.md`, `analysis/zstd_out_stats.md`, `analysis/zstd_out_word_stats.md`, and `analysis/zstd_out_dword_stats.md`.
Preliminary parsing suggests a fixed header of four 64-bit pointers followed by two 32-bit fields (flag/count), then 8-byte records of `[value][index]` where `value` packs a type/size (e.g., `0x04000030`, `0x06000040`) and `index` stays small. The `first_json_brace` hits appear to be 16-bit table data (values like `0x087b`, `0x087d`) rather than actual JSON. See `analysis/zstd_out_structure_notes.md` for details.

Crypto string scans of `libjnimultiengine*.so` did not surface obvious OpenSSL/mbedtls/EVP identifiers. A filtered uppercase token scan only hit an `Incomplete AES field` string and unrelated `ARO_CTR_*` image-processing tokens (see `analysis/crypto_string_hits_filtered.md`).

Dynamic symbols include `CreateFromEmbeddedBundle` and `TextEngineImpl::InitFromOwnedZipBuffer`, supporting an embedded bundle -> ZIP/container flow (see `analysis/dynsym_keywords_narrow.md`).

A dynsym scan of the `SmartEngines_full` build shows only standard NEEDED libs (`libm.so`, `liblog.so`, `libdl.so`, `libc.so`) and no `zstd`/`archive`/`crypto` symbol names; the only compression-adjacent name is `TextEngineImpl::InitFromOwnedZipBuffer` (see `analysis/dynsym_crypto_compress_scan.md`). This suggests compression helpers may be statically linked or stripped in that build.

Symbolized `SmartEngines_apktool` PLT scan shows `ZSTD_createDDict_advanced` and `ZSTD_DCtx_refDDict` callsites, indicating ZSTD dictionary construction and reference during decompression (see `analysis/apktool_plt_callsites_zstd_archive.md`). This strengthens the assumption that a dictionary is required for the ZSTD layer.

ZSTD dictionary magic (0x37A430EC) was not found in either `SmartEngines_full` or `SmartEngines_apktool` `libjnimultiengine.so`, suggesting the dictionary is constructed at runtime or embedded in bundle data rather than stored as a raw ZSTD dict in the binary (see `analysis/zstd_dict_magic_scan.md`).
