Searched `decompiled_code` and `decompiled_so` for `sebundle`, `.se`, `bundle_filename`, `BUNDLE_PATH`, `smartid.json`, `sdr.json`, `CreateFromEmbeddedBundle`, `InitFromOwnedZipBuffer`, `readAssetsFile`, and `AssetManager`. The only positive hits are the SWIG JNI entry points and native CreateFromEmbeddedBundle implementations; no strings indicating an on-disk bundle path or Android asset loading were found in either tree (no hits for `sebundle`, `.se`, `bundle_filename`, `BUNDLE_PATH`, `smartid.json`, `sdr.json`, `InitFromOwnedZipBuffer`, `readAssetsFile`, or `AssetManager`).

Smali scan (TestApps RegistrationScanner) shows the asset path and bundle filenames are defined in app code and passed directly into JNI. In `TestApps_apk/RegistrationScanner_full_src_blue_only/smali_classes3/com/smartengines/app/Model.smali`, the bundle file names are hardcoded as `bundle_codeengine_full.se`, `bundle_international_faces_liveness.se`, `bundle_newdocengine_demo_hiring_dsn.se`, and `bundle_textengine.se`, each wrapped in `EngineBundle$File`. `EngineLoader$load$1.smali` uses `UtilsKt.readAssetsFile(context, filePath)` (AssetManager.open) to load the bytes, then calls `Engine.createEngine([B)`; if bytes are null it falls back to `CreateFromEmbeddedBundle`. The same Model class lists the `assets/bundles` directory for diagnostics (`AssetManager.list("bundles")`), but the actual file path passed to `readAssetsFile` is the bare filename (no explicit `bundles/` prefix).

Production app (SmartEngines_apktool) mirrors the same flow: `SmartEngines_apktool/smali_classes3/com/smartengines/app/Model.smali` hardcodes the same `.se` filenames and lists `assets/bundles`, while `SmartEngines_apktool/smali_classes3/com/smartengines/engine/EngineLoader$load$1.smali` loads bytes via `UtilsKt.readAssetsFile(context, filePath)` and then calls `Engine.createEngine([B)` with the bundle bytes (no `bundles/` prefix in the path argument).

JNI create-with-bytes wrappers in `decompiled_code` explicitly pull `jbyteArray` content and pass it to native constructors: `Java_com_smartengines_text_jnitextengineJNI_TextEngine_Create__SWIG_12` @ `0x00936520` calls JNIEnv function pointers at offsets `0x5c0` (GetByteArrayElements) and `0x558` (GetArrayLength), then constructs `se::text::TextEngineImpl::TextEngineImpl(this, buffer, len, flag)` and releases the array via offset `0x600`. Similarly, `Java_com_smartengines_doc_jnidocengineJNI_DocEngine_Create__SWIG_12` @ `0x008d41dc` calls `se::doc::DocEngine::Create(buffer, len, flag)` with the same JNIEnv access pattern. These are concrete native entrypoints that accept bundle bytes from Java/Kotlin before the internal decoder chain.

JNI/native flow found: `decompiled_code/Java_com_smartengines_text_jnitextengineJNI_TextEngine_1CreateFromEmbeddedBundle_1_1SWIG_10.c` and `...SWIG_11.c` define JNI functions `Java_com_smartengines_text_jnitextengineJNI_TextEngine_1CreateFromEmbeddedBundle_1_1SWIG_10/11` that call `se::text::TextEngine::CreateFromEmbeddedBundle(...)`; the concrete implementation in `decompiled_code/_ALL_FUNCTIONS.c` (`se::text::TextEngine::CreateFromEmbeddedBundle(bool)`) calls `TextEngineImpl::FromEmbeddedBundle(false)` and `TextEngineImpl::GetVersion()` and returns a fixed version string. For doc engine, `decompiled_code/Java_com_smartengines_doc_jnidocengineJNI_DocEngine_1CreateFromEmbeddedBundle_1_1SWIG_10.c` and `...SWIG_11.c` call `FUN_00aff5a0()`, and `decompiled_code/_ALL_FUNCTIONS.c` shows `se::doc::DocEngine::CreateFromEmbeddedBundle(bool)` delegating to `FUN_00aff5a0(param_1)`, suggesting the JNI entry points route directly to the native embedded-bundle initializer but with no visible bundle filename/path in these decompilation outputs.

Files changed:
- analysis/decompiled_bundle_trace.md
