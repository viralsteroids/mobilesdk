# XOR key usage + next layer (static)

Static scan of `SmartEngines_full/lib/arm64-v8a/libjnimultiengine.so` confirms the 20-byte license hash appears twice in `.rodata` (file offsets `0x2db30f` and `0x2db3be`, both adjacent to `se_client_id__se_demo`). No direct pointer hits were found for either address (0x2db30f/0x2db3be) in the binary (no 4- or 8-byte absolute references), and prior ADRP+ADD scans likewise produced no xrefs, so access is likely indirect or via computed addresses. The only strong XOR candidate remains the dense EOR/ADD cluster at `0x1309f00-0x130a3e4` (treat as `FUN_01309f00`), which embeds the 40-byte constant table whose first 11 bytes match the offline XOR tail; no other XOR loops with an obvious 0x20 period were located in the static scans. The 12-byte constant is not present as a contiguous literal in the binary; it is best explained as `0x10` from the 21-byte header license field plus the 11-byte tail from the XOR cluster constants, yielding the 32-byte repeating XOR key (20-byte SHA-1 + 12-byte tail).

For the next layer, static evidence points to compression (ZSTD via libarchive) rather than an additional AES/ChaCha stage. The decoder chain shows `TextEngineImpl::InitFromOwnedZipBuffer` flowing into libarchive wrappers that call `archive_read_support_filter_zstd` and `archive_read_open_memory2`, and ZSTD callsites (`ZSTD_decompressStream`) are present inside the archive paths. Crypto string/constant scans did not surface AES S-boxes or ChaCha constants in `libjnimultiengine.so`, and the 12-byte tail is already accounted for by the XOR key. Post-XOR payloads remain high-entropy with no reliable magic, so an intermediate container/decompress step is the most defensible next layer candidate (ZSTD-backed archive), though a second cipher stage is not confirmed.
